from heapq import heappush, heappopfrom math import sqrtdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    def check_point_in_box(box, point):        if(point[0] >= box[0] and point[0] <= box[1] and point[1] >= box[2] and point[1] <= box[3]):            return True        return False    def euc_dist(point1, point2):        distance = sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)        return distance    def get_entry_point(point_from, box_from, box_to):        x = (max(box_from[0], box_to[0]),min(box_from[1], box_to[1]))        y = (max(box_from[2], box_to[2]),min(box_from[3], box_to[3]))        if (point_from[0] < x[0]):            aux_x = x[0]        else:            if(point_from[0] > x[1]):                aux_x = x[1]            else:                aux_x = point_from[0]        if (point_from[1] < y[0]):            aux_y = y[0]        else:            if(point_from[1] > y[1]):                aux_y = y[1]            else:                aux_y = point_from[1]        return (aux_x,aux_y)    #List of segments (pair of points)    path = []    boxes = []    cost = {}    parents = {}    entry_point = {}    next_nodes = []    initial_box = None    destination_box = None    found = False    for box in mesh['boxes']:        if(check_point_in_box(box, source_point) == True and initial_box == None):            initial_box = box            cost[box] = 0            heappush(next_nodes, (cost[box] + euc_dist(source_point, destination_point), box))            parents[box] = None            entry_point[box] = source_point        if(check_point_in_box(box, destination_point) == True and destination_box == None):            destination_box = box            #heappush(nodes_destination, (euc_dist(destination_point, source_point), box))            #cost_so_far[box] = 0        if(destination_box != None and initial_box != None):            break    #If one of the selected point is not in a box, there is no possible path between them    if(destination_box == None or initial_box == None):        print('No path!')        return path, boxes    while(next_nodes):        current = heappop(next_nodes)        print('current = ', current)        if(current[1] == destination_box):            found = True            boxes.append(current[1])            break        adjacents = mesh['adj'][current[1]]        for aux_box in adjacents:            if(aux_box in boxes):                continue            print('adj = ', aux_box)            aux_entry = get_entry_point(entry_point[current[1]], current[1], aux_box)            visited = False            for node in next_nodes:                if(aux_box == node[1]):                    visited = True                    #If the node was already in the list, but we've found a shorter path to it, we update its information                    if((cost[current[1]] + euc_dist(entry_point[current[1]], aux_entry)) + euc_dist(aux_entry, destination_point) < cost[aux_box] + euc_dist(entry_point[aux_box], destination_point)):                        cost[aux_box] = cost[current[1]] + euc_dist(entry_point[current[1]], aux_entry)                        parents[aux_box] = current[1]                        entry_point[aux_box] = aux_entry                        heappush(next_nodes, ((cost[aux_box] + euc_dist(entry_point[current[1]], entry_point[aux_box])) + euc_dist(entry_point[aux_box], destination_point), aux_box))                break            #If it is the first time we've seen the node            print('visited = ', visited)            if(visited == False):                cost[aux_box] = cost[current[1]] + euc_dist(entry_point[current[1]], aux_entry)                parents[aux_box] = current[1]                entry_point[aux_box] = aux_entry                heappush(next_nodes, ((cost[aux_box] + euc_dist(entry_point[current[1]], entry_point[aux_box])) + euc_dist(entry_point[aux_box], destination_point), aux_box))        boxes.append(current[1])    if(found == False):        print('No path!')                    return path, boxes