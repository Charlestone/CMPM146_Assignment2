from heapq import heappush, heappopfrom math import sqrt, infdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = []    initial_box = None    destination_box = None    nodes_source = []    nodes_destination = []    nodes_visited_from_source = []    nodes_visited_from_destination = []    entry_point_source = {}    entry_point_destination = {}    parents_from_source = {}    parents_from_destination = {}    cost_so_far = {}    print('source_point: ',source_point)    print('destination_point', destination_point)    #Check intial boxes    print('Please wait...')    for box in mesh['boxes']:        if(check_point_in_box(box, source_point) == True and not nodes_source):            initial_box = box            heappush(nodes_source, (calculate_euc_dist(source_point, destination_point), box))            cost_so_far[box] = 0            parents_from_source[box] = None            entry_point_source[box] = source_point        if(check_point_in_box(box, destination_point) == True and not nodes_destination):            destination_box = box            heappush(nodes_destination, (calculate_euc_dist(destination_point, source_point), box))            cost_so_far[box] = 0        if(nodes_destination and nodes_source):            break    cont = 0    if(destination_box == None or initial_box == None):        print('No path!')        return path, boxes    print('Initial boxes found')    while(nodes_source):        node_from_source = heappop(nodes_source)        #Early exiting condition        if(cont < 2):            print('actual box = ', node_from_source[1])        if(node_from_source[1] == destination_box):            break        adjacents = mesh['adj'][node_from_source[1]]        for aux_box in adjacents:            for aux_node in nodes_visited_from_source:                if (aux_box == aux_node[1]):                    continue            aux_entry = get_entry_point(entry_point_source[node_from_source[1]], node_from_source[1], aux_box)             aux_cost = calculate_euc_dist(entry_point_source[node_from_source[1]], aux_entry)            if(cont < 2):                print('box = ', aux_box, ' entry = ', aux_entry, ' cost = ', aux_cost)            if(aux_box not in cost_so_far or (aux_cost + cost_so_far[node_from_source[1]]) < cost_so_far[aux_box]):                parents_from_source[aux_box] = node_from_source[1]                entry_point_source[aux_box] = aux_entry                cost_so_far[aux_box] = aux_cost + cost_so_far[node_from_source[1]]                heappush(nodes_source, (aux_cost + cost_so_far[node_from_source[1]], aux_box))        cont += 1                nodes_visited_from_source.append(node_from_source)            if(node_from_source):        while(node_from_source[1] != initial_box):            boxes.append(node_from_source[1])            node_from_source = (1, parents_from_source[node_from_source[1]])        boxes.append(initial_box)    #We have the two initial boxes as nodes    #while(boxes_destiantion and boxes_source):    return path, boxesdef check_point_in_box(box, point):    if(point[0] >= box[0] and point[0] <= box[1] and point[1] >= box[2] and point[1] <= box[3]):        return True    return Falsedef calculate_euc_dist(point1, point2):    distance = sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)    return distancedef get_entry_point(point_from, box_from, box_to):    x = (max(box_from[0], box_to[0]),min(box_from[1], box_to[1]))    y = (max(box_from[2], box_to[2]),min(box_from[3], box_to[3]))    if (point_from[0] < x[0]):        aux_x = x[0]    else:        if(point_from[0] > x[1]):            aux_x = x[1]        else:            aux_x = point_from[0]    if (point_from[1] < y[0]):        aux_y = y[0]    else:        if(point_from[1] > y[1]):            aux_y = y[1]        else:            aux_y = point_from[1]    return (aux_x,aux_y)