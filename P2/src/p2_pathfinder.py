from heapq import heappush, heappopfrom math import sqrtdef check_point_in_box(box, point):    if(point[0] >= box[0] and point[0] <= box[1] and point[1] >= box[2] and point[1] <= box[3]):        return True    return Falsedef euc_dist(point1, point2):    distance = sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)    return distancedef get_entry_point(point_from, box_from, box_to):    x = (max(box_from[0], box_to[0]),min(box_from[1], box_to[1]))    y = (max(box_from[2], box_to[2]),min(box_from[3], box_to[3]))    if (point_from[0] < x[0]):        aux_x = x[0]    else:        if(point_from[0] > x[1]):            aux_x = x[1]        else:            aux_x = point_from[0]    if (point_from[1] < y[0]):        aux_y = y[0]    else:        if(point_from[1] > y[1]):            aux_y = y[1]        else:            aux_y = point_from[1]    return (aux_x,aux_y)def find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """        #List of segments (pair of points)    path = []    boxes = []    cost = {}    parents = {}    entry_point = {}    next_nodes = []    initial_box = None    destination_box = None    found = False    #Get the initial box and the destination box    for box in mesh['boxes']:        if(check_point_in_box(box, source_point) == True and initial_box == None):            initial_box = box            cost[box] = 0            heappush(next_nodes, (cost[box] + euc_dist(source_point, destination_point), box))            parents[box] = None            entry_point[box] = source_point        if(check_point_in_box(box, destination_point) == True and destination_box == None):            destination_box = box            #heappush(nodes_destination, (euc_dist(destination_point, source_point), box))            #cost_so_far[box] = 0        if(destination_box != None and initial_box != None):            break    #If one of the selected point is not in a box, there is no possible path between them    if(destination_box == None or initial_box == None):        print('No path!')        return path, boxes    while(next_nodes):        #Pop the next element of the heap        current = heappop(next_nodes)        print('current = ', current)        #Check if the current box is the destination box        if(current[1] == destination_box):            found = True            boxes.append(current[1])            break        #Obtain the adjacents to the current box        adjacents = mesh['adj'][current[1]]        #For every adjacent        for adj in adjacents:            print('adj = ', adj)            #Get the entry point to the adjacent            aux_entry = get_entry_point(entry_point[current[1]], current[1], adj)            #Get the total cost            adj_cost = euc_dist(aux_entry, destination_point) + euc_dist(aux_entry, entry_point[current[1]]) + cost[current[1]]            #If the adj is new or we've found a better cost for it            if((adj not in cost) or (adj_cost < cost[adj] + euc_dist(entry_point[adj], destination_point))):                cost[adj] = euc_dist(aux_entry, entry_point[current[1]]) + cost[current[1]]                parents[adj] = current[1]                entry_point[adj] = aux_entry                heappush(next_nodes, (adj_cost, adj))    path.append((destination_point,entry_point[current[1]]))    while(current[1] != initial_box):        path.append((entry_point[parents[current[1]]],entry_point[current[1]]))        boxes.append(current[1])        current = (1, parents[current[1]])    path.append((source_point, entry_point[current[1]]))    boxes.append(current[1])    if(found == False):        print('No path!')                    return path, boxes